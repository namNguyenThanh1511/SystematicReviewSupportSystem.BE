# üì¶ Import Batch API Documentation
**Backend API Reference for Frontend Integration**

> **‚ö†Ô∏è NOTE:** This is **backend API documentation**. This repository contains only the .NET backend code.  
> The TypeScript examples below are **reference implementations** for frontend developers to copy and adapt in their own frontend projects.

## Overview
The Import Batch API manages import batches within search executions in a Systematic Literature Review (SLR) system. An import batch represents a single import operation (file upload or manual entry) that brings papers into the system.

**Base URL:** `/api`

**Backend Framework:** ASP.NET Core (.NET 8)

**Authentication:** Not specified in controller (likely JWT - check with backend team)

---

## üìç API Endpoints

### 1. Create Import Batch

**Purpose:** Create a new import batch for a search execution

#### Basic Info
- **Method:** `POST`
- **Route:** `/api/search-executions/{searchExecutionId}/import-batches`
- **Description:** Records a new import batch (file upload or manual entry)

#### Request Details

**Headers:**
```
Content-Type: application/json
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `searchExecutionId` | `string (UUID)` | ‚úÖ Yes | The ID of the search execution |

**Request Body Schema (TypeScript reference for frontend):**
```typescript
// Frontend developers: Copy these types to your TypeScript project
interface CreateImportBatchRequest {
  searchExecutionId: string;  // UUID - Must match route param
  fileName?: string | null;   // Optional - Name of imported file
  fileType?: string | null;   // Optional - e.g., "RIS", "CSV", "BibTeX"
  source?: string | null;     // Optional - e.g., "IEEE Xplore", "PubMed"
  totalRecords: number;       // Required - Number of records in this batch
  importedBy?: string | null; // Optional - User who performed import
}
```

**Corresponding C# DTO (backend):**
- `SRSS.IAM.Services.DTOs.Identification.CreateImportBatchRequest`

**Validation Rules:**
- ‚úÖ `searchExecutionId` in route MUST match `searchExecutionId` in body
- ‚úÖ `totalRecords` must be >= 0
- ‚úÖ `searchExecutionId` must reference an existing search execution

#### Response Details

**Success Response (201 Created):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<ImportBatchResponse> {
  isSuccess: true;
  message: string;  // "Import batch created successfully."
  data: ImportBatchResponse;
  errors: null;
}

interface ImportBatchResponse {
  id: string;                     // UUID - Generated by system
  searchExecutionId: string | null; // UUID - Can be null for manual imports
  fileName: string | null;        // Name of imported file
  fileType: string | null;        // File type (RIS, CSV, etc.)
  source: string | null;          // Source database
  totalRecords: number;           // Number of records imported
  importedBy: string | null;      // User who imported
  importedAt: string;             // ISO 8601 datetime - Auto-set to current time
  createdAt: string;              // ISO 8601 datetime
  modifiedAt: string;             // ISO 8601 datetime
}
```

**Corresponding C# DTOs (backend):**
- Response: `SRSS.IAM.Services.DTOs.Identification.ImportBatchResponse`
- Wrapper: `Shared.Models.ApiResponse<T>`

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **400 Bad Request** | Route ID ‚â† Body ID | `{ isSuccess: false, message: "SearchExecution ID in route does not match ID in request body.", errors: null }` |
| **400 Bad Request** | Validation failed | `{ isSuccess: false, message: "Invalid input", errors: [...] }` |
| **500 Internal Server Error** | Search execution not found | `{ isSuccess: false, message: "SearchExecution with ID {id} not found.", errors: null }` |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Validates that the search execution exists
2. Creates a new import batch record
3. Sets `importedAt` to current UTC time
4. Saves to database and returns the created record
5. Updates the search execution's `importBatchCount` (automatic)

**Important conditions:**
- The search execution must exist before creating an import batch
- `importedAt` is auto-set; you cannot customize it
- `totalRecords` should match the actual number of papers imported

**Side effects:**
- A new import batch is created in the database
- The search execution's `importBatchCount` is incremented
- Papers can now be linked to this import batch

#### Frontend Integration Notes

**When to call:**
- After user uploads a RIS/CSV file
- After manual paper entry
- When importing papers from external sources

**Common pitfalls:**
- ‚ö†Ô∏è **Route-body mismatch:** Ensure `searchExecutionId` in URL matches the one in request body
- ‚ö†Ô∏è Set `totalRecords` accurately - this is used for statistics

**Example API Call (reference implementation for frontend):**
```typescript
// Frontend developers: Adapt this code for your HTTP client (fetch, axios, etc.)
async function createImportBatch(
  searchExecutionId: string,
  data: CreateImportBatchRequest
): Promise<ImportBatchResponse> {
  const response = await fetch(
    `/api/search-executions/${searchExecutionId}/import-batches`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getToken()}`
      },
      body: JSON.stringify(data)
    }
  );

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message);
  }

  const result = await response.json();
  return result.data;
}

// Usage example
const importBatch = await createImportBatch(
  'search-execution-id',
  {
    searchExecutionId: 'search-execution-id',
    fileName: 'papers_2024.ris',
    fileType: 'RIS',
    source: 'IEEE Xplore',
    totalRecords: 150,
    importedBy: 'user@example.com'
  }
);
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.ImportBatchController.CreateImportBatch`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.CreateImportBatchAsync`

---

### 2. Get Import Batch by ID

**Purpose:** Retrieve details of a specific import batch

#### Basic Info
- **Method:** `GET`
- **Route:** `/api/import-batches/{id}`
- **Description:** Get detailed information about an import batch

#### Request Details

**Headers:**
```
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `string (UUID)` | ‚úÖ Yes | Import batch ID |

**Query Parameters:** None

**Request Body:** None

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<ImportBatchResponse> {
  isSuccess: true;
  message: string;  // "Import batch retrieved successfully."
  data: ImportBatchResponse;
  errors: null;
}
```

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **404 Not Found** | Import batch doesn't exist | `{ isSuccess: false, message: "ImportBatch not found.", errors: null }` |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Queries database for import batch by ID
2. Returns the import batch details if found
3. Throws exception if not found (handled by global middleware)

**Example API Call (reference implementation for frontend):**
```typescript
async function getImportBatch(id: string): Promise<ImportBatchResponse> {
  const response = await fetch(`/api/import-batches/${id}`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${getToken()}`
    }
  });

  if (!response.ok) {
    throw new Error('Failed to fetch import batch');
  }

  const result = await response.json();
  return result.data;
}
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.ImportBatchController.GetImportBatchById`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.GetImportBatchByIdAsync`

---

### 3. Get Import Batches by Search Execution

**Purpose:** Retrieve all import batches for a specific search execution

#### Basic Info
- **Method:** `GET`
- **Route:** `/api/search-executions/{searchExecutionId}/import-batches`
- **Description:** List all import operations for a search execution

#### Request Details

**Headers:**
```
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `searchExecutionId` | `string (UUID)` | ‚úÖ Yes | Search execution ID |

**Query Parameters:** None (no pagination in current implementation)

**Request Body:** None

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<ImportBatchResponse[]> {
  isSuccess: true;
  message: string;  // "Import batches retrieved successfully."
  data: ImportBatchResponse[];  // Array of import batches
  errors: null;
}
```

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **200 OK** | No import batches found | `{ isSuccess: true, message: "...", data: [], errors: null }` (empty array) |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Queries all import batches for the search execution
2. Returns an array (can be empty if no imports yet)
3. No pagination - returns all results

**Example API Call (reference implementation for frontend):**
```typescript
async function getImportBatchesBySearchExecution(
  searchExecutionId: string
): Promise<ImportBatchResponse[]> {
  const response = await fetch(
    `/api/search-executions/${searchExecutionId}/import-batches`,
    {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${getToken()}`
      }
    }
  );

  if (!response.ok) {
    throw new Error('Failed to fetch import batches');
  }

  const result = await response.json();
  return result.data || [];
}

// Usage with display logic
const batches = await getImportBatchesBySearchExecution('search-exec-id');

if (batches.length === 0) {
  showMessage('No imports yet for this search');
} else {
  // Sort by date (most recent first)
  const sorted = batches.sort((a, b) => 
    new Date(b.importedAt).getTime() - new Date(a.importedAt).getTime()
  );
  displayImportHistory(sorted);
}
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.ImportBatchController.GetImportBatchesBySearchExecution`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.GetImportBatchesBySearchExecutionIdAsync`

---

### 4. Get Import Batches by Identification Process

**Purpose:** Retrieve all import batches for an identification process (across all search executions)

#### Basic Info
- **Method:** `GET`
- **Route:** `/api/identification-processes/{identificationProcessId}/import-batches`
- **Description:** List all import operations across all search executions in an identification process

#### Request Details

**Headers:**
```
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `identificationProcessId` | `string (UUID)` | ‚úÖ Yes | Identification process ID |

**Query Parameters:** None

**Request Body:** None

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<ImportBatchResponse[]> {
  isSuccess: true;
  message: string;  // "Import batches retrieved successfully."
  data: ImportBatchResponse[];  // Array of all import batches
  errors: null;
}
```

#### Business Logic Summary

**What happens:**
1. Finds all search executions for the identification process
2. Retrieves all import batches for those search executions
3. Returns aggregated list

**Example API Call (reference implementation for frontend):**
```typescript
async function getImportBatchesByProcess(
  identificationProcessId: string
): Promise<ImportBatchResponse[]> {
  const response = await fetch(
    `/api/identification-processes/${identificationProcessId}/import-batches`,
    {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${getToken()}`
      }
    }
  );

  if (!response.ok) {
    throw new Error('Failed to fetch import batches');
  }

  const result = await response.json();
  return result.data || [];
}
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.ImportBatchController.GetImportBatchesByIdentificationProcess`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.GetImportBatchesByIdentificationProcessIdAsync`

---

### 5. Update Import Batch

**Purpose:** Update details of an existing import batch

#### Basic Info
- **Method:** `PUT`
- **Route:** `/api/import-batches/{id}`
- **Description:** Modify import batch metadata

#### Request Details

**Headers:**
```
Content-Type: application/json
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `string (UUID)` | ‚úÖ Yes | Import batch ID |

**Request Body Schema (TypeScript reference for frontend):**
```typescript
// Frontend developers: Copy this type to your TypeScript project
interface UpdateImportBatchRequest {
  id: string;                       // UUID - Must match route param
  fileName?: string | null;         // Optional - Update file name
  fileType?: string | null;         // Optional - Update file type
  source?: string | null;           // Optional - Update source
  totalRecords?: number | null;     // Optional - Update record count
  importedBy?: string | null;       // Optional - Update importer
}
```

**Corresponding C# DTO (backend):**
- `SRSS.IAM.Services.DTOs.Identification.UpdateImportBatchRequest`

**Validation Rules:**
- ‚úÖ `id` in route MUST match `id` in body
- ‚úÖ All fields are optional (null = no update)
- ‚ö†Ô∏è Cannot update `importedAt`, `searchExecutionId`

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<ImportBatchResponse> {
  isSuccess: true;
  message: string;  // "Import batch updated successfully."
  data: ImportBatchResponse;  // Updated import batch
  errors: null;
}
```

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **400 Bad Request** | Route ID ‚â† Body ID | `{ isSuccess: false, message: "ID in route does not match ID in request body.", errors: null }` |
| **500 Internal Server Error** | Import batch not found | `{ isSuccess: false, message: "ImportBatch with ID {id} not found.", errors: null }` |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Finds the import batch by ID
2. Updates only the fields provided (not null)
3. Updates `modifiedAt` timestamp
4. Returns the updated record

**Example API Call (reference implementation for frontend):**
```typescript
async function updateImportBatch(
  id: string,
  updates: Partial<UpdateImportBatchRequest>
): Promise<ImportBatchResponse> {
  const response = await fetch(`/api/import-batches/${id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getToken()}`
    },
    body: JSON.stringify({
      id,
      ...updates
    })
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message);
  }

  const result = await response.json();
  return result.data;
}

// Usage example
await updateImportBatch('batch-id', {
  fileName: 'corrected_filename.ris',
  totalRecords: 148  // Corrected count
});
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.ImportBatchController.UpdateImportBatch`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.UpdateImportBatchAsync`

---

### 6. Delete Import Batch

**Purpose:** Remove an import batch record

#### Basic Info
- **Method:** `DELETE`
- **Route:** `/api/import-batches/{id}`
- **Description:** Delete an import batch

#### Request Details

**Headers:**
```
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `string (UUID)` | ‚úÖ Yes | Import batch ID |

**Query Parameters:** None

**Request Body:** None

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse {
  isSuccess: true;
  message: string;  // "Import batch deleted successfully."
  errors: null;
}
```

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **404 Not Found** | Import batch doesn't exist | `{ isSuccess: false, message: "ImportBatch not found.", errors: null }` |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Finds the import batch by ID
2. Deletes it from the database
3. Returns success

**Important conditions:**
- Import batch must exist
- ‚ö†Ô∏è **May cascade delete linked papers** (check database constraints)
- Irreversible operation

**Example API Call (reference implementation for frontend):**
```typescript
async function deleteImportBatch(id: string): Promise<void> {
  const confirmed = await showConfirmDialog(
    'Delete Import Batch',
    'Are you sure? This may delete associated papers and cannot be undone.'
  );

  if (!confirmed) return;

  const response = await fetch(`/api/import-batches/${id}`, {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${getToken()}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message);
  }
}
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.ImportBatchController.DeleteImportBatch`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.DeleteImportBatchAsync`

---

### 7. Get Papers by Import Batch

**Purpose:** Retrieve all papers that were imported in a specific import batch

#### Basic Info
- **Method:** `GET`
- **Route:** `/api/import-batches/{id}/papers`
- **Description:** Get all papers belonging to a specific import batch

#### Request Details

**Headers:**
```
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `string (UUID)` | ‚úÖ Yes | Import batch ID |

**Query Parameters:** None

**Request Body:** None

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<PaperResponse[]> {
  isSuccess: true;
  message: string;  // "Retrieved {count} papers from import batch."
  data: PaperResponse[];
  errors: null;
}

interface PaperResponse {
  id: string;                          // UUID

  // Core Metadata
  title: string;
  authors?: string | null;
  abstract?: string | null;
  doi?: string | null;
  publicationType?: string | null;
  publicationYear?: string | null;
  publicationYearInt?: number | null;
  publicationDate?: string | null;     // ISO 8601 DateTimeOffset
  volume?: string | null;
  issue?: string | null;
  pages?: string | null;
  publisher?: string | null;
  language?: string | null;
  keywords?: string | null;
  url?: string | null;

  // Conference Metadata
  conferenceName?: string | null;
  conferenceLocation?: string | null;
  conferenceCountry?: string | null;
  conferenceYear?: number | null;

  // Journal Metadata
  journal?: string | null;
  journalIssn?: string | null;

  // Source Tracking
  source?: string | null;
  importedAt?: string | null;          // ISO 8601 DateTimeOffset
  importedBy?: string | null;

  // Selection Status (derived dynamically)
  selectionStatus?: string | null;     // e.g., "Included", "Excluded", "Pending"
  selectionStatusText?: string | null;

  // Access
  pdfUrl?: string | null;
  fullTextAvailable?: boolean | null;
  accessType?: string | null;          // e.g., "OpenAccess", "Subscription"
  accessTypeText?: string | null;

  // Audit
  createdAt: string;                   // ISO 8601 DateTimeOffset
  modifiedAt: string;                  // ISO 8601 DateTimeOffset
}
```

**Example Response Body:**
```json
{
  "isSuccess": true,
  "message": "Retrieved 47 papers from import batch.",
  "data": [
    {
      "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "title": "Machine Learning in Healthcare: A Systematic Review",
      "authors": "Smith, J.; Doe, A.; Johnson, M.",
      "abstract": "This paper reviews recent advances in machine learning...",
      "doi": "10.1234/example.2024.001",
      "publicationType": "Journal Article",
      "publicationYear": "2024",
      "publicationYearInt": 2024,
      "volume": "15",
      "issue": "3",
      "pages": "123-145",
      "publisher": "Springer",
      "journal": "Journal of Medical Informatics",
      "journalIssn": "1234-5678",
      "url": "https://doi.org/10.1234/example.2024.001",
      "keywords": "machine learning, healthcare, systematic review",
      "source": "RIS",
      "importedAt": "2024-01-15T10:30:00Z",
      "importedBy": "researcher@university.edu",
      "accessType": "OpenAccess",
      "accessTypeText": "OpenAccess",
      "createdAt": "2024-01-15T10:30:00Z",
      "modifiedAt": "2024-01-15T10:30:00Z"
    }
  ],
  "errors": null
}
```

**Corresponding C# DTO (backend):**
- `SRSS.IAM.Services.DTOs.Paper.PaperResponse`

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **404 Not Found** | Import batch doesn't exist | `{ isSuccess: false, message: "ImportBatch with ID {id} not found.", errors: null }` |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Validates import batch exists
2. Queries all papers linked to the import batch via `ImportBatchId` foreign key
3. Maps paper entities to response DTOs
4. Returns the list with count in message

**Important conditions:**
- Returns empty array `[]` if import batch has no papers
- Papers are returned in database order (no sorting applied)
- All paper metadata fields are included in response

**Use Cases:**
- **View Import Results:** Display what was imported in a specific batch
- **Verify Import Quality:** Check if imported papers have correct metadata
- **Export Subset:** Allow users to export papers from a specific import batch
- **Duplicate Detection:** Compare papers within the same batch
- **Audit Trail:** Track which papers came from which source/file

**Example API Call (reference implementation for frontend):**
```typescript
async function getPapersByImportBatch(importBatchId: string): Promise<PaperResponse[]> {
  const response = await fetch(`/api/import-batches/${importBatchId}/papers`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${getToken()}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message);
  }

  const result = await response.json();
  return result.data;
}

// Usage example - Display papers from an import batch
const papers = await getPapersByImportBatch('batch-id-123');
console.log(`Found ${papers.length} papers in this batch`);

papers.forEach(paper => {
  console.log(`- ${paper.title} (${paper.publicationYear})`);
  console.log(`  DOI: ${paper.doi || 'N/A'}`);
  console.log(`  Authors: ${paper.authors || 'N/A'}`);
});

// Example - Create a data table for the UI
interface PaperTableRow {
  id: string;
  title: string;
  authors: string;
  year: string;
  doi: string;
  source: string;
}

function mapToTableData(papers: PaperResponse[]): PaperTableRow[] {
  return papers.map(p => ({
    id: p.id,
    title: p.title,
    authors: p.authors || 'Unknown',
    year: p.publicationYear || 'N/A',
    doi: p.doi || 'N/A',
    source: p.source || 'Unknown'
  }));
}

const tableData = mapToTableData(papers);
```

**React Component Example (reference for frontend):**
```typescript
import React, { useEffect, useState } from 'react';

interface ImportBatchPapersProps {
  importBatchId: string;
}

export const ImportBatchPapers: React.FC<ImportBatchPapersProps> = ({ importBatchId }) => {
  const [papers, setPapers] = useState<PaperResponse[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadPapers = async () => {
      try {
        setLoading(true);
        const data = await getPapersByImportBatch(importBatchId);
        setPapers(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load papers');
      } finally {
        setLoading(false);
      }
    };

    loadPapers();
  }, [importBatchId]);

  if (loading) return <div>Loading papers...</div>;
  if (error) return <div>Error: {error}</div>;
  if (papers.length === 0) return <div>No papers in this import batch</div>;

  return (
    <div>
      <h3>Papers ({papers.length})</h3>
      <table>
        <thead>
          <tr>
            <th>Title</th>
            <th>Authors</th>
            <th>Year</th>
            <th>DOI</th>
            <th>Source</th>
          </tr>
        </thead>
        <tbody>
          {papers.map(paper => (
            <tr key={paper.id}>
              <td>{paper.title}</td>
              <td>{paper.authors || 'N/A'}</td>
              <td>{paper.publicationYear || 'N/A'}</td>
              <td>{paper.doi || 'N/A'}</td>
              <td>{paper.source || 'N/A'}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.ImportBatchController.GetPapersByImportBatch`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.GetPapersByImportBatchIdAsync`

---

## üîÑ Complete Frontend Integration Example
  );
  
  if (!confirmed) return;

  const response = await fetch(`/api/import-batches/${id}`, {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${getToken()}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message);
  }
}
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.ImportBatchController.DeleteImportBatch`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.DeleteImportBatchAsync`

---

## üéØ Complete TypeScript Type Definitions

> **üì¶ For Frontend Developers:** Copy these TypeScript definitions to your frontend project.  
> These are **reference implementations** based on the C# backend DTOs.

**Backend Source:**
- C# DTOs: `SRSS.IAM.Services.DTOs.Identification`
- C# Entities: `SRSS.IAM.Repositories.Entities`
- API Wrapper: `Shared.Models.ApiResponse`

```typescript
// ========================
// REQUEST TYPES
// ========================

export interface CreateImportBatchRequest {
  searchExecutionId: string;  // UUID format
  fileName?: string | null;   
  fileType?: string | null;   
  source?: string | null;     
  totalRecords: number;       // Required
  importedBy?: string | null; 
}

export interface UpdateImportBatchRequest {
  id: string;                 // UUID format
  fileName?: string | null;   
  fileType?: string | null;   
  source?: string | null;     
  totalRecords?: number | null;
  importedBy?: string | null; 
}

// ========================
// RESPONSE TYPES
// ========================

export interface ImportBatchResponse {
  id: string;                     // UUID
  searchExecutionId: string | null; // UUID - nullable
  fileName: string | null;        
  fileType: string | null;        
  source: string | null;          
  totalRecords: number;           
  importedBy: string | null;      
  importedAt: string;             // ISO 8601 datetime
  createdAt: string;              // ISO 8601 datetime
  modifiedAt: string;             // ISO 8601 datetime
}

// ========================
// API WRAPPER
// ========================

export interface ApiResponse<T = void> {
  isSuccess: boolean;
  message: string;
  data?: T;
  errors?: ApiError[] | null;
}

export interface ApiError {
  code: string;
  message: string;
}

// ========================
// API CLIENT
// ========================

export class ImportBatchApiClient {
  constructor(private baseUrl: string, private getToken: () => string) {}

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`,
        ...options.headers,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.message || 'API request failed');
    }

    return data;
  }

  async createImportBatch(
    searchExecutionId: string,
    request: CreateImportBatchRequest
  ): Promise<ImportBatchResponse> {
    const response = await this.request<ImportBatchResponse>(
      `/api/search-executions/${searchExecutionId}/import-batches`,
      {
        method: 'POST',
        body: JSON.stringify(request),
      }
    );
    return response.data!;
  }

  async getImportBatch(id: string): Promise<ImportBatchResponse> {
    const response = await this.request<ImportBatchResponse>(
      `/api/import-batches/${id}`,
      { method: 'GET' }
    );
    return response.data!;
  }

  async getImportBatchesBySearchExecution(
    searchExecutionId: string
  ): Promise<ImportBatchResponse[]> {
    const response = await this.request<ImportBatchResponse[]>(
      `/api/search-executions/${searchExecutionId}/import-batches`,
      { method: 'GET' }
    );
    return response.data || [];
  }

  async getImportBatchesByProcess(
    identificationProcessId: string
  ): Promise<ImportBatchResponse[]> {
    const response = await this.request<ImportBatchResponse[]>(
      `/api/identification-processes/${identificationProcessId}/import-batches`,
      { method: 'GET' }
    );
    return response.data || [];
  }

  async updateImportBatch(
    id: string,
    request: UpdateImportBatchRequest
  ): Promise<ImportBatchResponse> {
    const response = await this.request<ImportBatchResponse>(
      `/api/import-batches/${id}`,
      {
        method: 'PUT',
        body: JSON.stringify(request),
      }
    );
    return response.data!;
  }

  async deleteImportBatch(id: string): Promise<void> {
    await this.request<void>(`/api/import-batches/${id}`, {
      method: 'DELETE',
    });
  }
}

// ========================
// USAGE EXAMPLE
// ========================

// Initialize client
const apiClient = new ImportBatchApiClient(
  'https://api.yourapp.com',
  () => localStorage.getItem('authToken') || ''
);

// Example: Create import batch after file upload
async function handleFileImport(
  searchExecutionId: string,
  file: File,
  recordCount: number
) {
  try {
    const batch = await apiClient.createImportBatch(
      searchExecutionId,
      {
        searchExecutionId,
        fileName: file.name,
        fileType: file.name.split('.').pop()?.toUpperCase(),
        source: 'IEEE Xplore',
        totalRecords: recordCount,
        importedBy: getCurrentUser().email
      }
    );
    console.log('Import batch created:', batch);
    return batch.id;
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}

// Example: Get import history for a search
async function loadImportHistory(searchExecutionId: string) {
  try {
    const batches = await apiClient.getImportBatchesBySearchExecution(
      searchExecutionId
    );
    
    // Sort by date (newest first)
    const sorted = batches.sort((a, b) => 
      new Date(b.importedAt).getTime() - new Date(a.importedAt).getTime()
    );
    
    displayImportHistory(sorted);
  } catch (error) {
    console.error('Error:', error);
  }
}

// Example: Delete import batch
async function handleDeleteImport(id: string) {
  const confirmed = confirm(
    'Delete this import batch? Papers may be deleted.'
  );
  
  if (!confirmed) return;

  try {
    await apiClient.deleteImportBatch(id);
    toast.success('Import batch deleted');
    refreshList();
  } catch (error) {
    toast.error(error.message);
  }
}
```

---

## üîó Backend Implementation Reference

For backend developers working on this API:

**Controller:**
- `SRSS.IAM.API.Controllers.ImportBatchController`

**Services:**
- `SRSS.IAM.Services.IdentificationService.IIdentificationService`
- `SRSS.IAM.Services.IdentificationService.IdentificationService`

**DTOs:**
- `SRSS.IAM.Services.DTOs.Identification.CreateImportBatchRequest`
- `SRSS.IAM.Services.DTOs.Identification.UpdateImportBatchRequest`
- `SRSS.IAM.Services.DTOs.Identification.ImportBatchResponse`

**Entities:**
- `SRSS.IAM.Repositories.Entities.ImportBatch`

**Common:**
- `Shared.Models.ApiResponse<T>`
- `Shared.Middlewares.GlobalExceptionMiddleware`

---

## üîî Important Notes for Frontend Team

### 1. **File Upload Workflow**
```typescript
// Typical workflow
1. User selects file
2. Parse file (client or server-side)
3. Create import batch with totalRecords count
4. Import papers and link to batch ID
5. Display import batch in history
```

### 2. **Import Batch vs Papers**
- **Import Batch:** Container for import operation metadata
- **Papers:** Individual research papers (separate API)
- One batch can have many papers

### 3. **TotalRecords Field**
- Should match actual number of papers imported
- Used for statistics and validation
- Update if record count changes

### 4. **Search Execution Relationship**
- Import batch belongs to search execution
- Search execution's `importBatchCount` auto-updates
- Deleting all batches allows search execution deletion

### 5. **Date Handling**
- `importedAt` is auto-set (cannot customize)
- All dates in ISO 8601 format
- Use for chronological display

---

## üìà Integration with Search Execution API

The Import Batch API works closely with the Search Execution API:

```typescript
// Workflow example
// 1. Get search execution
const searchExec = await searchExecutionApi.getSearchExecution(id);
console.log(`Has ${searchExec.importBatchCount} batches`);

// 2. Get import batches for this search
const batches = await importBatchApi.getImportBatchesBySearchExecution(id);

// 3. Create new import batch
const newBatch = await importBatchApi.createImportBatch(id, {...});

// 4. Search execution's importBatchCount auto-increments
const updated = await searchExecutionApi.getSearchExecution(id);
console.log(`Now has ${updated.importBatchCount} batches`);
```

---

## üöÄ Quick Integration Checklist

- [ ] Copy TypeScript types to your project
- [ ] Set up API client with authentication
- [ ] Implement file upload workflow
- [ ] Display import history timeline
- [ ] Show batch details (file name, count, date)
- [ ] Handle delete with confirmation
- [ ] Link papers to import batches
- [ ] Update UI after import operations
- [ ] Display import statistics
- [ ] Test error scenarios

---

**Document Version:** 1.0  
**Created:** January 2024  
**API Version:** v1  
**Backend Framework:** ASP.NET Core (.NET 8)  
**Status:** ‚úÖ Implementation Complete
