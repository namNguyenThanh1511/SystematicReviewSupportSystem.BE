# üìã Search Execution API Documentation
**Backend API Reference for Frontend Integration**

> **‚ö†Ô∏è NOTE:** This is **backend API documentation**. This repository contains only the .NET backend code.  
> The TypeScript examples below are **reference implementations** for frontend developers to copy and adapt in their own frontend projects.

## Overview
The Search Execution API manages search executions within identification processes in a Systematic Literature Review (SLR) system. A search execution represents a single search performed on a database or a manual import of papers.

**Base URL:** `/api`

**Backend Framework:** ASP.NET Core (.NET 8)

**Authentication:** Not specified in controller (likely JWT - check with backend team)

---

## üìç API Endpoints

### 1. Create Search Execution

**Purpose:** Create a new search execution record for an identification process

#### Basic Info
- **Method:** `POST`
- **Route:** `/api/identification-processes/{identificationProcessId}/search-executions`
- **Description:** Records a new search execution (database search or manual import)

#### Request Details

**Headers:**
```
Content-Type: application/json
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `identificationProcessId` | `string (UUID)` | ‚úÖ Yes | The ID of the identification process |

**Request Body Schema (TypeScript reference for frontend):**
```typescript
// Frontend developers: Copy these types to your TypeScript project
interface CreateSearchExecutionRequest {
  identificationProcessId: string;  // UUID - Must match route param
  searchSource: string;              // Required - e.g., "IEEE Xplore", "PubMed"
  searchQuery?: string | null;       // Optional - The search query used
  type: SearchExecutionType;         // Required - 0=DatabaseSearch, 1=ManualImport
  notes?: string | null;             // Optional - Additional notes
}

enum SearchExecutionType {
  DatabaseSearch = 0,
  ManualImport = 1
}
```

**Corresponding C# DTO (backend):**
- `SRSS.IAM.Services.DTOs.Identification.CreateSearchExecutionRequest`
- `SRSS.IAM.Repositories.Entities.SearchExecutionType`

**Validation Rules:**
- ‚úÖ `identificationProcessId` in route MUST match `identificationProcessId` in body
- ‚úÖ `searchSource` cannot be empty
- ‚úÖ `identificationProcessId` must reference an existing identification process
- ‚úÖ `type` must be 0 (DatabaseSearch) or 1 (ManualImport)

#### Response Details

**Success Response (201 Created):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<SearchExecutionResponse> {
  isSuccess: true;
  message: string;  // "Search execution created successfully."
  data: SearchExecutionResponse;
  errors: null;
}

interface SearchExecutionResponse {
  id: string;                          // UUID - Generated by system
  identificationProcessId: string;     // UUID
  searchSource: string;                // Database or source name
  searchQuery: string | null;          // Search query used
  executedAt: string;                  // ISO 8601 datetime - Auto-set to current time
  resultCount: number;                 // Initially 0, updated when papers imported
  type: SearchExecutionType;           // 0 or 1
  typeText: string;                    // "DatabaseSearch" or "ManualImport"
  notes: string | null;                // Additional notes
  createdAt: string;                   // ISO 8601 datetime
  modifiedAt: string;                  // ISO 8601 datetime
}
```

**Corresponding C# DTOs (backend):**
- Response: `SRSS.IAM.Services.DTOs.Identification.SearchExecutionResponse`
- Wrapper: `Shared.Models.ApiResponse<T>`

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **400 Bad Request** | Route ID ‚â† Body ID | `{ isSuccess: false, message: "IdentificationProcess ID in route does not match ID in request body.", errors: null }` |
| **400 Bad Request** | Validation failed | `{ isSuccess: false, message: "Invalid input", errors: [...] }` |
| **500 Internal Server Error** | Identification process not found | `{ isSuccess: false, message: "IdentificationProcess with ID {id} not found.", errors: null }` |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Validates that the identification process exists
2. Creates a new search execution record
3. Sets `executedAt` to current UTC time
4. Initializes `resultCount` to 0
5. Saves to database and returns the created record

**Important conditions:**
- The identification process must exist before creating a search execution
- `resultCount` starts at 0 and is updated later when papers are imported
- `executedAt` is auto-set; you cannot customize it

**Side effects:**
- A new search execution is created in the database
- The search execution is associated with the identification process

#### Frontend Integration Notes

**When to call:**
- After user performs a database search
- After user manually imports papers from a file
- Before importing papers (to get the `searchExecutionId` for linking)

**Common pitfalls:**
- ‚ö†Ô∏è **Route-body mismatch:** Ensure `identificationProcessId` in URL matches the one in request body
- ‚ö†Ô∏è Missing `searchSource` - this is required
- ‚ö†Ô∏è Don't try to set `resultCount` - it's managed by the system

**Loading/Error handling:**
```typescript
// Show loading spinner while creating
// On success: Navigate to search execution detail or paper import flow
// On 400: Show validation errors to user
// On 500: Show generic error message
```

**Example API Call (reference implementation for frontend):**
```typescript
// Frontend developers: Adapt this code for your HTTP client (fetch, axios, etc.)
async function createSearchExecution(
  identificationProcessId: string,
  data: CreateSearchExecutionRequest
): Promise<SearchExecutionResponse> {
  const response = await fetch(
    `/api/identification-processes/${identificationProcessId}/search-executions`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getToken()}`
      },
      body: JSON.stringify(data)
    }
  );

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message);
  }

  const result = await response.json();
  return result.data;
}

// Usage example
const newSearchExecution = await createSearchExecution(
  'a1b2c3d4-...',
  {
    identificationProcessId: 'a1b2c3d4-...',
    searchSource: 'IEEE Xplore',
    searchQuery: 'machine learning AND systematic review',
    type: 0, // DatabaseSearch
    notes: 'Initial search with broad keywords'
  }
);
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.SearchExecutionController.CreateSearchExecution`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.CreateSearchExecutionAsync`

---

### 2. Get Search Execution by ID

**Purpose:** Retrieve details of a specific search execution

#### Basic Info
- **Method:** `GET`
- **Route:** `/api/search-executions/{id}`
- **Description:** Get detailed information about a search execution

#### Request Details

**Headers:**
```
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `string (UUID)` | ‚úÖ Yes | Search execution ID |

**Query Parameters:** None

**Request Body:** None

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<SearchExecutionResponse> {
  isSuccess: true;
  message: string;  // "Search execution retrieved successfully."
  data: SearchExecutionResponse;
  errors: null;
}
```

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **404 Not Found** | Search execution doesn't exist | `{ isSuccess: false, message: "SearchExecution not found.", errors: null }` |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Queries database for search execution by ID
2. Returns the search execution details if found
3. Throws exception if not found (handled by global middleware)

**Important conditions:**
- Search execution must exist
- Returns current state including `resultCount` (may be updated after paper imports)

#### Frontend Integration Notes

**When to call:**
- When displaying search execution details
- After creating a search execution to get latest state
- When user clicks on a search execution in a list
- To check current `resultCount` after paper imports

**Common pitfalls:**
- ‚ö†Ô∏è Don't cache this data for too long - `resultCount` changes as papers are imported

**Example API Call (reference implementation for frontend):**
```typescript
// Frontend developers: Adapt this code for your project
async function getSearchExecution(id: string): Promise<SearchExecutionResponse> {
  const response = await fetch(`/api/search-executions/${id}`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${getToken()}`
    }
  });

  if (!response.ok) {
    throw new Error('Failed to fetch search execution');
  }

  const result = await response.json();
  return result.data;
}
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.SearchExecutionController.GetSearchExecutionById`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.GetSearchExecutionByIdAsync`

---

### 3. Get All Search Executions for Identification Process

**Purpose:** Retrieve all search executions associated with a specific identification process

#### Basic Info
- **Method:** `GET`
- **Route:** `/api/identification-processes/{identificationProcessId}/search-executions`
- **Description:** List all searches performed for an identification process

#### Request Details

**Headers:**
```
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `identificationProcessId` | `string (UUID)` | ‚úÖ Yes | Identification process ID |

**Query Parameters:** None (no pagination in current implementation)

**Request Body:** None

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<SearchExecutionResponse[]> {
  isSuccess: true;
  message: string;  // "Search executions retrieved successfully."
  data: SearchExecutionResponse[];  // Array of search executions
  errors: null;
}
```

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **200 OK** | No search executions found | `{ isSuccess: true, message: "...", data: [], errors: null }` (empty array) |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Queries all search executions for the identification process
2. Returns an array (can be empty if no searches yet)
3. No pagination - returns all results

**Important conditions:**
- Returns empty array if no search executions found (not an error)
- Results are not explicitly sorted (may be in creation order)

**Pagination:**
- ‚ö†Ô∏è **Not implemented** - all results returned at once
- Could be a performance issue with hundreds of searches

#### Frontend Integration Notes

**When to call:**
- When displaying the identification process detail page
- To show a list of all searches performed
- Before creating a new search to show existing ones

**Common pitfalls:**
- ‚ö†Ô∏è No pagination - could return large datasets
- ‚ö†Ô∏è Empty array is a valid success response (not an error)
- ‚ö†Ô∏è Order not guaranteed - you may want to sort by `executedAt` on frontend

**Loading/Error handling:**
```typescript
// Show loading spinner
// On success with empty array: Show "No searches yet" message
// On success with data: Display list
// On error: Show error message
```

**Example API Call (reference implementation for frontend):**
```typescript
// Frontend developers: Adapt this code for your project
async function getSearchExecutionsByProcess(
  identificationProcessId: string
): Promise<SearchExecutionResponse[]> {
  const response = await fetch(
    `/api/identification-processes/${identificationProcessId}/search-executions`,
    {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${getToken()}`
      }
    }
  );

  if (!response.ok) {
    throw new Error('Failed to fetch search executions');
  }

  const result = await response.json();
  return result.data || [];
}

// Usage with display logic
const searchExecutions = await getSearchExecutionsByProcess('a1b2c3d4-...');

if (searchExecutions.length === 0) {
  showMessage('No search executions found for this process');
} else {
  // Sort by date (most recent first) - backend doesn't guarantee order
  const sorted = searchExecutions.sort((a, b) => 
    new Date(b.executedAt).getTime() - new Date(a.executedAt).getTime()
  );
  displaySearchExecutions(sorted);
}
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.SearchExecutionController.GetSearchExecutionsByIdentificationProcess`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.GetSearchExecutionsByIdentificationProcessIdAsync`

---

### 4. Update Search Execution

**Purpose:** Update details of an existing search execution

#### Basic Info
- **Method:** `PUT`
- **Route:** `/api/search-executions/{id}`
- **Description:** Modify search execution metadata (source, query, type, notes)

#### Request Details

**Headers:**
```
Content-Type: application/json
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `string (UUID)` | ‚úÖ Yes | Search execution ID |

**Request Body Schema (TypeScript reference for frontend):**
```typescript
// Frontend developers: Copy this type to your TypeScript project
interface UpdateSearchExecutionRequest {
  id: string;                        // UUID - Must match route param
  searchSource?: string | null;      // Optional - Update source name
  searchQuery?: string | null;       // Optional - Update query
  type?: SearchExecutionType | null; // Optional - Change type
  notes?: string | null;             // Optional - Update notes
}
```

**Corresponding C# DTO (backend):**
- `SRSS.IAM.Services.DTOs.Identification.UpdateSearchExecutionRequest`

**Validation Rules:**
- ‚úÖ `id` in route MUST match `id` in body
- ‚úÖ All fields are optional (null = no update)
- ‚úÖ If `searchSource` provided, cannot be empty string
- ‚ö†Ô∏è Cannot update `executedAt`, `resultCount`, `identificationProcessId`

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse<SearchExecutionResponse> {
  isSuccess: true;
  message: string;  // "Search execution updated successfully."
  data: SearchExecutionResponse;  // Updated search execution
  errors: null;
}
```

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **400 Bad Request** | Route ID ‚â† Body ID | `{ isSuccess: false, message: "ID in route does not match ID in request body.", errors: null }` |
| **500 Internal Server Error** | Search execution not found | `{ isSuccess: false, message: "SearchExecution with ID {id} not found.", errors: null }` |
| **500 Internal Server Error** | Server error | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Finds the search execution by ID
2. Updates only the fields provided (not null)
3. Skips null or empty fields (keeps existing values)
4. Updates `modifiedAt` timestamp
5. Returns the updated record

**Important conditions:**
- Partial update - only provide fields you want to change
- `null` means "don't update this field"
- Empty string for `searchSource` is rejected
- Cannot change `identificationProcessId` or `executedAt`

**Side effects:**
- `modifiedAt` timestamp is updated
- Only specified fields are changed

#### Frontend Integration Notes

**When to call:**
- When user edits search execution details
- To correct/refine search metadata
- To add/update notes after initial creation

**Common pitfalls:**
- ‚ö†Ô∏è **Route-body mismatch:** Ensure `id` in URL matches the one in request body
- ‚ö†Ô∏è Send only fields you want to update (don't send all fields with null)
- ‚ö†Ô∏è Cannot update `resultCount` - managed by import process
- ‚ö†Ô∏è Cannot change which identification process it belongs to

**Example API Call (reference implementation for frontend):**
```typescript
// Frontend developers: Adapt this code for your project
async function updateSearchExecution(
  id: string,
  updates: Partial<UpdateSearchExecutionRequest>
): Promise<SearchExecutionResponse> {
  const response = await fetch(`/api/search-executions/${id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getToken()}`
    },
    body: JSON.stringify({
      id,
      ...updates
    })
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message);
  }

  const result = await response.json();
  return result.data;
}

// Usage example - Update only notes
await updateSearchExecution('a1b2c3d4-...', {
  notes: 'Updated notes after review'
});

// Usage example - Update multiple fields
await updateSearchExecution('a1b2c3d4-...', {
  searchSource: 'Scopus',
  searchQuery: 'refined query string',
  notes: 'Corrected source and query'
});
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.SearchExecutionController.UpdateSearchExecution`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.UpdateSearchExecutionAsync`

---

### 5. Delete Search Execution

**Purpose:** Remove a search execution record

#### Basic Info
- **Method:** `DELETE`
- **Route:** `/api/search-executions/{id}`
- **Description:** Delete a search execution (‚ö†Ô∏è likely deletes associated papers too)

#### Request Details

**Headers:**
```
Authorization: Bearer {token} (if authentication enabled)
```

**Path Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `string (UUID)` | ‚úÖ Yes | Search execution ID |

**Query Parameters:** None

**Request Body:** None

#### Response Details

**Success Response (200 OK):**
```typescript
// Frontend developers: Expected response structure
interface ApiResponse {
  isSuccess: true;
  message: string;  // "Search execution deleted successfully."
  errors: null;
}
```

**Error Responses:**

| Status | Scenario | Response |
|--------|----------|----------|
| **404 Not Found** | Search execution doesn't exist | `{ isSuccess: false, message: "SearchExecution not found.", errors: null }` |
| **500 Internal Server Error** | Server error (cascade constraints) | `{ isSuccess: false, message: "An error occurred", errors: null }` |

#### Business Logic Summary

**What happens:**
1. Finds the search execution by ID
2. Deletes it from the database
3. Returns success (boolean `true` from service, not returned to client)

**Important conditions:**
- Search execution must exist
- ‚ö†Ô∏è **DANGER:** May cascade delete associated data (imported papers, import batches)
- Irreversible operation

**Side effects:**
- Search execution is permanently deleted
- Associated import batches may be deleted (check database constraints)
- Papers linked to this search execution may be affected

#### Frontend Integration Notes

**When to call:**
- When user confirms deletion of a search execution
- **Only after explicit user confirmation** - this is destructive

**Common pitfalls:**
- ‚ö†Ô∏è **DANGER:** This may delete imported papers - confirm with backend team
- ‚ö†Ô∏è No soft delete - permanent removal
- ‚ö†Ô∏è Cannot undo - always show confirmation dialog
- ‚ö†Ô∏è May fail if papers are still linked (foreign key constraints)

**Loading/Error handling:**
```typescript
// ALWAYS show confirmation dialog first
// Show loading spinner during deletion
// On success: Refresh list, show success message
// On 404: Item already deleted or never existed
// On 500: Likely has dependent data - show appropriate message
```

**Example API Call (reference implementation for frontend):**
```typescript
// Frontend developers: Adapt this code for your project
async function deleteSearchExecution(id: string): Promise<void> {
  // Always confirm first!
  const confirmed = await showConfirmDialog(
    'Delete Search Execution',
    'Are you sure? This may delete associated papers and cannot be undone.'
  );

  if (!confirmed) return;

  const response = await fetch(`/api/search-executions/${id}`, {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${getToken()}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    if (response.status === 404) {
      throw new Error('Search execution not found or already deleted');
    } else {
      throw new Error('Cannot delete: may have associated papers');
    }
  }

  // Success - no data returned
  return;
}

// Usage example
try {
  await deleteSearchExecution('a1b2c3d4-...');
  showSuccessMessage('Search execution deleted successfully');
  refreshSearchExecutionList();
} catch (error) {
  showErrorMessage(error.message);
}
```

**Backend Implementation:**
- Controller: `SRSS.IAM.API.Controllers.SearchExecutionController.DeleteSearchExecution`
- Service: `SRSS.IAM.Services.IdentificationService.IIdentificationService.DeleteSearchExecutionAsync`

---

## üéØ Complete TypeScript Type Definitions

> **üì¶ For Frontend Developers:** Copy these TypeScript definitions to your frontend project.  
> These are **reference implementations** based on the C# backend DTOs.

**Backend Source:**
- C# DTOs: `SRSS.IAM.Services.DTOs.Identification`
- C# Entities: `SRSS.IAM.Repositories.Entities`
- API Wrapper: `Shared.Models.ApiResponse`

```typescript
// ========================
// ENUMS
// ========================

export enum SearchExecutionType {
  DatabaseSearch = 0,
  ManualImport = 1
}

// ========================
// REQUEST TYPES
// ========================

export interface CreateSearchExecutionRequest {
  identificationProcessId: string;  // UUID format
  searchSource: string;              // Required, non-empty
  searchQuery?: string | null;       
  type: SearchExecutionType;        
  notes?: string | null;            
}

export interface UpdateSearchExecutionRequest {
  id: string;                        // UUID format
  searchSource?: string | null;      
  searchQuery?: string | null;       
  type?: SearchExecutionType | null; 
  notes?: string | null;            
}

// ========================
// RESPONSE TYPES
// ========================

export interface SearchExecutionResponse {
  id: string;                        // UUID
  identificationProcessId: string;   // UUID
  searchSource: string;              
  searchQuery: string | null;        
  executedAt: string;                // ISO 8601 datetime
  resultCount: number;               // Managed by system
  type: SearchExecutionType;         
  typeText: string;                  // Human-readable type
  notes: string | null;              
  createdAt: string;                 // ISO 8601 datetime
  modifiedAt: string;                // ISO 8601 datetime
}

// ========================
// API WRAPPER
// ========================

export interface ApiResponse<T = void> {
  isSuccess: boolean;
  message: string;
  data?: T;
  errors?: ApiError[] | null;
}

export interface ApiError {
  code: string;
  message: string;
}

// ========================
// API CLIENT
// ========================

export class SearchExecutionApiClient {
  constructor(private baseUrl: string, private getToken: () => string) {}

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`,
        ...options.headers,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.message || 'API request failed');
    }

    return data;
  }

  async createSearchExecution(
    identificationProcessId: string,
    request: CreateSearchExecutionRequest
  ): Promise<SearchExecutionResponse> {
    const response = await this.request<SearchExecutionResponse>(
      `/api/identification-processes/${identificationProcessId}/search-executions`,
      {
        method: 'POST',
        body: JSON.stringify(request),
      }
    );
    return response.data!;
  }

  async getSearchExecution(id: string): Promise<SearchExecutionResponse> {
    const response = await this.request<SearchExecutionResponse>(
      `/api/search-executions/${id}`,
      { method: 'GET' }
    );
    return response.data!;
  }

  async getSearchExecutionsByProcess(
    identificationProcessId: string
  ): Promise<SearchExecutionResponse[]> {
    const response = await this.request<SearchExecutionResponse[]>(
      `/api/identification-processes/${identificationProcessId}/search-executions`,
      { method: 'GET' }
    );
    return response.data || [];
  }

  async updateSearchExecution(
    id: string,
    request: UpdateSearchExecutionRequest
  ): Promise<SearchExecutionResponse> {
    const response = await this.request<SearchExecutionResponse>(
      `/api/search-executions/${id}`,
      {
        method: 'PUT',
        body: JSON.stringify(request),
      }
    );
    return response.data!;
  }

  async deleteSearchExecution(id: string): Promise<void> {
    await this.request<void>(`/api/search-executions/${id}`, {
      method: 'DELETE',
    });
  }
}

// ========================
// USAGE EXAMPLE
// ========================

// Frontend developers: Example usage patterns for your project

// Initialize client
const apiClient = new SearchExecutionApiClient(
  'https://api.yourapp.com',
  () => localStorage.getItem('authToken') || ''
);

// Example: Create search execution
async function handleCreateSearchExecution() {
  try {
    const searchExecution = await apiClient.createSearchExecution(
      'identification-process-id',
      {
        identificationProcessId: 'identification-process-id',
        searchSource: 'IEEE Xplore',
        searchQuery: 'machine learning AND systematic review',
        type: SearchExecutionType.DatabaseSearch,
        notes: 'Initial broad search'
      }
    );
    console.log('Created:', searchExecution);
  } catch (error) {
    console.error('Error:', error);
  }
}

// Example: Get all search executions for a process
async function handleLoadSearchExecutions(processId: string) {
  try {
    const executions = await apiClient.getSearchExecutionsByProcess(processId);

    if (executions.length === 0) {
      console.log('No search executions yet');
    } else {
      // Sort by execution date (newest first)
      const sorted = executions.sort((a, b) => 
        new Date(b.executedAt).getTime() - new Date(a.executedAt).getTime()
      );
      console.log('Search executions:', sorted);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

// Example: Update search execution
async function handleUpdateSearchExecution(id: string) {
  try {
    const updated = await apiClient.updateSearchExecution(id, {
      id,
      notes: 'Updated notes after review',
      searchQuery: 'Refined query string'
    });
    console.log('Updated:', updated);
  } catch (error) {
    console.error('Error:', error);
  }
}

// Example: Delete with confirmation
async function handleDeleteSearchExecution(id: string) {
  const confirmed = confirm(
    'Are you sure? This may delete associated papers and cannot be undone.'
  );

  if (!confirmed) return;

  try {
    await apiClient.deleteSearchExecution(id);
    console.log('Deleted successfully');
    // Refresh the list
    await handleLoadSearchExecutions('process-id');
  } catch (error) {
    console.error('Error:', error);
  }
}
```

---

## üîó Backend Implementation Reference

For backend developers working on this API:

**Controller:**
- `SRSS.IAM.API.Controllers.SearchExecutionController`

**Services:**
- `SRSS.IAM.Services.IdentificationService.IIdentificationService`
- `SRSS.IAM.Services.IdentificationService.IdentificationService`

**DTOs:**
- `SRSS.IAM.Services.DTOs.Identification.CreateSearchExecutionRequest`
- `SRSS.IAM.Services.DTOs.Identification.UpdateSearchExecutionRequest`
- `SRSS.IAM.Services.DTOs.Identification.SearchExecutionResponse`

**Entities:**
- `SRSS.IAM.Repositories.Entities.SearchExecution`
- `SRSS.IAM.Repositories.Entities.SearchExecutionType`

**Common:**
- `Shared.Models.ApiResponse<T>`
- `Shared.Middlewares.GlobalExceptionMiddleware`

---

## üîî Important Notes for Frontend Team

### 1. **Route-Body ID Mismatch Validation**
- Both `POST` and `PUT` endpoints validate that IDs match between route and body
- **Always ensure consistency** to avoid 400 errors
- This is a backend safety check, but handle it gracefully in frontend

### 2. **ResultCount is Read-Only**
- `resultCount` is managed by the backend during paper import
- Don't try to update it manually
- Refresh the search execution to get the latest count after imports

### 3. **No Pagination**
- The list endpoint returns ALL search executions
- Could be slow with many searches
- Consider client-side pagination or request backend to add pagination

### 4. **Delete is Destructive**
- May cascade delete papers and import batches
- **Always show confirmation dialog**
- Check with backend about cascade behavior

### 5. **Date Formatting**
- All dates are ISO 8601 format: `"2024-01-15T10:30:00.123Z"`
- Use `new Date(dateString)` to parse
- Display with appropriate timezone conversion

### 6. **Empty Arrays are Success**
- Getting an empty array of search executions is NOT an error
- Show appropriate "no data" UI instead of error message

### 7. **Error Handling**
- All errors follow the `ApiResponse` format
- Check `isSuccess` field before accessing `data`
- Display `message` field to users
- Log `errors` array for debugging

### 8. **Type Enum Display**
- Backend returns both `type` (number) and `typeText` (string)
- Use `typeText` for display: "DatabaseSearch" or "ManualImport"
- Use `type` for filtering/comparison

### 9. **Exception Handling Architecture**
- The backend uses **GlobalExceptionMiddleware** for centralized error handling
- Controllers don't use try-catch blocks - they let exceptions bubble up
- All service-layer exceptions are automatically converted to appropriate HTTP responses
- You'll always receive a structured `ApiResponse` format, even for errors

---

## üöÄ Quick Integration Checklist

- [ ] Copy TypeScript types to your project
- [ ] Set up API client with authentication
- [ ] Implement confirmation dialog for delete
- [ ] Handle empty array states (no searches yet)
- [ ] Sort search executions by date on display
- [ ] Show loading states during API calls
- [ ] Display human-readable type using `typeText`
- [ ] Format dates appropriately for user timezone
- [ ] Add validation to ensure route IDs match body IDs
- [ ] Test error scenarios (404, 500, validation errors)
- [ ] Consider adding client-side caching for list view

---

## ‚ùì Questions for Backend Team

1. **Authentication:** Is JWT required? What format?
2. **Cascade Delete:** Does deleting a search execution delete associated papers?
3. **Pagination:** Should list endpoint support pagination for performance?
4. **Sorting:** What's the default sort order for list endpoint?
5. **Permissions:** Any role-based restrictions on these endpoints?
6. **Rate Limiting:** Any limits on API calls?
7. **Import Flow:** How does `resultCount` get updated? Is there a webhook/event?

---

## üìä Data Flow Diagram

```
Frontend Flow:
1. User initiates search ‚Üí Call POST /search-executions
2. Backend creates record with resultCount=0
3. Frontend receives searchExecutionId
4. User imports papers ‚Üí Link papers to searchExecutionId
5. Backend auto-updates resultCount
6. Frontend polls/refreshes GET /search-executions/{id} to show updated count
```

---

## üîó Related APIs

- **Identification Process API:** Manage the parent identification process
- **Paper Import API:** Import papers and link to search executions (updates resultCount)
- **Import Batch API:** Manage batches of imported papers

---

**Document Version:** 1.0  
**Last Updated:** 2024  
**API Version:** v1  
**Backend Framework:** ASP.NET Core (.NET 8)  
**Contact:** Backend Development Team
